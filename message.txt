import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

/**
 * 11/10/2021
 * CSC414 - Theory of Computation
 * Midterm Section 2.1 - Programming in Polynomial Complexity
 * Completed by: Zach Bohn
 * True Sarmiento
 * Chris Styerwalt
 * <p>
 * The goal of this section is to write a solver for x given c, an n × 1 vector,
 * b, an n × 1 vector, A, an n × n matrix, and s, an n × 1 vector, which returns
 * values for x, an n × 1 vector that maximize the dot product: (c^T)x such that
 * Ax + s = b. Write this in Java for n of any size, n ≥ 3.
 */
public class EmExPlusBee {
    public static ArrayList<ArrayList<Double>> mA = new ArrayList<>();
    public static ArrayList<ArrayList<Double>> mB = new ArrayList<>();
    public static ArrayList<ArrayList<Double>> mS = new ArrayList<>();
    public static ArrayList<ArrayList<Double>> mX = new ArrayList<>();
    public static int mSize;
    public static boolean done = false;
    public static final DecimalFormat df = new DecimalFormat("#.0000");

    public static void solve() {
        // Step 1: mB = mB - mS
        for (int i = 0; i < mSize; i++)
            mB.get(i).set(0, Double.parseDouble(df.format(mB.get(i).get(0) - mS.get(i).get(0))));

        // Step 2: Concatenate mB to mA (mA = n x n+1 matrix)
        for (int i = 0; i < mSize; i++)
            mA.get(i).add(mB.get(i).get(0));

        // Step 3: Perform row operations on mA
        solveRecursiveHelp(0);

        // Step 4: Solve for mX (backtrack with recursion)
        System.out.println((mX));
    }

    /**
     * Recursive method to solve for mX
     *
     * @param i index variable to track matrix row/recursive level
     * @return solution to an index of mX, until mX is full
     */
    public static double solveRecursiveHelp(int i) {
        if (i == mSize || done) {
            done = true;
            return mA.get(i - 1).get(mSize);

        } else if (i < mSize) {
            scaleRow(mA.get(i), 1 / mA.get(i).get(i));
            for (int j = i + 1; j < mSize; j++) {
                subtractScaledRow(mA.get(j), mA.get(i), mA.get(j).get(i));
            }
            double x = solveRecursiveHelp(++i);
            for (int u = i - 2; u >= 0; u--) {
                subtractScaledRow(mA.get(u), mA.get(i-1), mA.get(u).get(i-1));
            }
            mX.get(i-1).add(x);
        }
        if (0 <= i - 2) return mA.get(i - 2).get(mSize);
        else return 0.0;
    }

//    /**
//     * Swaps the indexes of r1 and r2 in mA
//     *
//     * @param r1 row being swapped for r2
//     * @param r2 row being swapped for r1
//     */
//    public static void switchRows(ArrayList<Double> r1, ArrayList<Double> r2) {
//        ArrayList<Double> rTemp = r1;
//        r1 = r2;
//        r2 = rTemp;
//        System.out.println("Switched rows " + r2 + " and " + r1);
//    }

    /**
     * Multiplies every index in rA by x
     *
     * @param rA is the row index of mA
     * @param x  is the scaling factor
     */
    public static void scaleRow(ArrayList<Double> rA, double x) {
        System.out.print("Scaling row " + rA + " by " + x + " = ");
        for (int i = 0; i < rA.size(); i++) {
            rA.set(i, Double.parseDouble(df.format(rA.get(i) * x)));
        }
        System.out.println(rA);
    }

    /**
     * Multiplies r1 by x and subtracts the result from r2
     * r2 = r2 - x * r1
     *
     * @param r2 is the row that is being subtracted from
     * @param r1 is the row that is being scaled
     * @param x  is the scaling factor
     */
    public static void subtractScaledRow(ArrayList<Double> r2, ArrayList<Double> r1, double x) {
        System.out.print("Subtract " + r1 + " * " + x + " from " + r2 + " to get ");
        for (int i = 0; i < r2.size(); i++) {
            r2.set(i, Double.parseDouble(df.format(r2.get(i) - (r1.get(i) * x))));
        }
        System.out.println(r2);
    }

    /**
     * Initializes test matrices from the assignment
     */
    public static void testMatrixInit() {
        mA.add(new ArrayList<>());
        mA.add(new ArrayList<>());
        mA.add(new ArrayList<>());
        mA.get(0).add(3.2);
        mA.get(0).add(8.7);
        mA.get(0).add(5.9);
        mA.get(1).add(2.4);
        mA.get(1).add(3.1);
        mA.get(1).add(1.1);
        mA.get(2).add(9.7);
        mA.get(2).add(6.1);
        mA.get(2).add(0.3);

        mB.add(new ArrayList<>());
        mB.add(new ArrayList<>());
        mB.add(new ArrayList<>());
        mB.get(0).add(5.0);
        mB.get(1).add(12.9);
        mB.get(2).add(2.0);

        mS.add(new ArrayList<>());
        mS.add(new ArrayList<>());
        mS.add(new ArrayList<>());
        mS.get(0).add(3.7);
        mS.get(1).add(3.8);
        mS.get(2).add(1.0);

        mX.add(new ArrayList<>());
        mX.add(new ArrayList<>());
        mX.add(new ArrayList<>());


    }

    /**
     * Initializes matrices with mSize
     */
    public static void matrixInit() {
        Random random = new Random();
        for (int i = 0; i < mSize; i++) {
            mA.add(new ArrayList<>());
            for (int j = 0; j < mSize; j++)
                mA.get(i).add(random.nextInt(1000 - 100) / 100.0);
            mB.add(new ArrayList<>());
            mB.get(i).add(random.nextInt(1000 - 100) / 100.0);
            mS.add(new ArrayList<>());
            mS.get(i).add(random.nextInt(1000 - 100) / 100.0);
            mX.add(new ArrayList<>());
        }
    }

    /**
     * Control method for class EmExPlusBee
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Use test matrices? (y/n) ");
        String testYn = scanner.next();
        if (testYn.charAt(0) == 'y') {
            System.out.println("Running test matrices...");
            mSize = 3;
            testMatrixInit();
        } else {
            System.out.print("Enter matrix size n: ");
            mSize = scanner.nextInt();
            scanner.close();
            System.out.println("Running random matrices of size n...");
            matrixInit();
        }
        solve();
    }
}